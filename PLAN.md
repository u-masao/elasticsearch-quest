# アプリケーション開発ドキュメント: elasticsearch quest

## 1. 背景 (Background)

* Elasticsearchは、ログ分析、全文検索、データ可視化など、現代の多くのアプリケーションで重要な役割を担う強力な検索・分析エンジンです。
* しかし、その豊富な機能と柔軟なクエリDSL（ドメイン固有言語）は、初学者にとって習得が難しい側面があります。特に、実践的なクエリ作成スキルを身につけるには、実際にクエリを書いて試行錯誤する経験が不可欠です。
* 既存の学習リソース（ドキュメント、ブログ記事、動画など）は存在しますが、インタラクティブにクエリを試しながら、ステップバイステップで体系的に学び、かつ個々の疑問点に対するフィードバックを得られる環境は限られています。
* 特に、クエリの正誤だけでなく、「なぜ間違っているのか」「どうすればもっと良くなるのか」といった質の高いフィードバックや、学習モチベーションを維持するための仕組みが求められています。

## 2. 目的 (Purpose)

* 本アプリケーション「elasticsearch quest」は、ユーザーが**インタラクティブなクエスト**を通じて、Elasticsearchのクエリ作成スキルを**効果的かつ楽しく**習得できる環境を提供することを目的とします。
* **ターゲットユーザー**は、Elasticsearchの**初心者から基本的なクエリを学びたい中級者**です。
* AIアシスタント（LLM）による**個別最適化されたサポート**（ヒント、評価、改善提案）と、**ゲーム要素**（ポイント、アチーブメント、応援画像）により、ユーザーの学習意欲を高め、**挫折しにくい学習体験**を提供します。
* 最終的に、ユーザーが自信を持ってElasticsearchクエリを作成できるようになることを目指します。

## 3. 要求事項 (Requirements)

### 3.1. 機能要求

* ユーザーは、提示された課題（クエスト）に対してElasticsearchクエリを作成し、実行できること。
* ユーザーは、実行したクエリの結果（ヒットしたドキュメントや集計結果）を確認できること。
* ユーザーは、作成したクエリがクエストの目的を達成しているかどうかの正誤判定を受けられること。
* ユーザーは、クエリが不正解だった場合や行き詰まった場合に、段階的なヒントを得られること。
* ユーザーは、作成したクエリの品質（効率性、ベストプラクティス等）に関する定性的な評価と改善提案を受けられること。
* ユーザーは、クエストのクリア状況に応じてポイントを獲得できること。
* ユーザーは、特定の条件を達成することでアチーブメント（バッジ等）を獲得できること。
* ユーザーは、クエストクリアなどのタイミングで、学習を応援する画像が表示されること。
* ユーザーは、ステップバイステップで段階的に難易度が上がるクエストを進められること。
* ユーザーは、自身の学習進捗（クリアしたクエスト、獲得ポイント、アチーブメント）を確認できること。
* ユーザーは、アプリケーションで使われるサンプルデータが固定されており、他のユーザーと同じ条件で学習できること。（教えあいやすさのため）

### 3.2. 非機能要求（プロトタイプとして）

* アプリケーションの利用にかかるOpenAI APIコストを計測できること。
* 応答速度は、プロトタイプ段階では最優先事項ではないこと。
* 学習体験の再現性が確保されていること（固定データによる）。

## 4. 要件 (Specifications)

### 4.1. 機能要件

* **クエスト管理:**
    * 事前に定義されたクエスト（ID, 問題文, 対象データ(固定), 期待結果/評価基準, 関連度データ(nDCG用), ヒント案等）をSQLiteデータベースで管理する。
    * クエストは難易度順に構成される。
* **サンプルデータ:**
    * 固定のサンプルデータセット（JSON形式）を複数テーマ（例: 商品、ログ）で用意し、アプリに同梱する。
    * アプリ起動時または初期化時に、データをElasticsearchコンテナの指定インデックスに投入する。
* **UI (Gradio):**
    * 現在のクエスト情報（問題文、ステップ番号等）を表示する。
    * クエリ入力用のテキストエリアを設ける。
    * クエリ実行ボタンを設ける。
    * クエリ実行結果（ヒット件数、ドキュメント例、集計結果等）を表示するエリアを設ける。
    * 正誤判定結果、LLMからのフィードバック（ヒント、評価、改善提案）を表示するエリアを設ける。
    * 獲得ポイント、アチーブメント、応援画像を表示するエリアを設ける。
    * ユーザーのステータス（累計ポイント、達成アチーブメント等）を表示する画面（またはエリア）を設ける。
* **クエリ実行・評価:**
    * ユーザーが入力したクエリをバックエンド経由でElasticsearchに送信し、実行する。
    * **正誤判定:** 事前に定義された期待結果（ヒット件数、特定ドキュメントの有無、集計結果の値、nDCGスコア等）と実際の実行結果を比較し、判定する。
    * **LLMによる補助:**
        * 正誤判定の結果やユーザーのクエリを基に、LLM (OpenAI Assistant) がヒント、定性評価（クエリの書き方）、改善提案を生成する。
        * 生成されたフィードバックをUIに表示する。
* **ポイントシステム:**
    * クエストクリア時に、難易度や試行回数に応じてポイントを付与するロジックを実装する。
    * 累計ポイントをSQLiteに記録する。
* **アチーブメントシステム:**
    * 達成条件（例: 特定クエストクリア、連続正解、特定クエリ使用）と対応するバッジ等を定義する。
    * 条件達成を検知し、獲得情報をSQLiteに記録し、UIに表示する。
* **応援画像生成:**
    * クエストクリア等のタイミングで、LLM (OpenAI Assistant) が状況に応じたプロンプトを生成する。
    * 生成されたプロンプトをDALL-E 3 APIに送信し、画像を生成する。
    * 生成された画像をUIに表示する。
* **状態管理:**
    * ユーザーの現在のクエスト、累計ポイント、試行履歴、獲得アチーブメント等の状態をSQLiteデータベースで永続管理する。

### 4.2. 技術要件

* **UIフレームワーク:** Gradio
* **バックエンド言語:** Python
* **LLM連携:** OpenAI Agents SDK (Assistants API)
* **クエリエンジン:** Elasticsearch (Dockerコンテナ上で実行)
* **データベース:** SQLite
* **Elasticsearchクライアント:** `elasticsearch-py` ライブラリ
* **アーキテクチャ:** UI (Gradio) - バックエンド (Python/OpenAI SDK) - LLM (OpenAI API) - DB (SQLite) - クエリエンジン (Elasticsearch) が連携する構成。バックエンドはAPIサーバーとして機能するか、Gradioのイベントハンドラ内で直接ロジックを実行する。MCP (Model-Controller-Prompter) の考え方を参考に、ロジックを整理する。

### 4.3. 非機能要件

* **コスト計測:** 各OpenAI AssistantのRun完了時に`usage`フィールドからトークン数を取得し、SQLiteに記録する。
* **パフォーマンス:** プロトタイプ段階では応答速度の最適化は必須としない。LLMの応答待ち時間は許容する。
* **セキュリティ:** プロトタイプ段階では厳密なセキュリティ対策（入力サニタイズ、アクセス制御等）は必須としないが、Elasticsearchへの不適切なクエリ（大量データ取得、インデックス操作等）はある程度制限する考慮が必要。
* **保守性・拡張性:** 段階的開発アプローチを採用し、各フェーズで機能を整理する。コードの可読性やモジュール性にも配慮する。

## 5. 開発計画 (Development Plan)

### 5.1. 段階的開発アプローチ

以下のフェーズに分けて開発を進める。

* **フェーズ1 (MVP - Minimum Viable Product):** コアとなる学習サイクル（クエスト提示→クエリ入力→実行→基本評価→基本ヒント）を確立する。
* **フェーズ2 (評価・ゲーム性向上):** LLMによる評価機能の強化と、ポイント・アチーブメントシステムを導入する。
* **フェーズ3 (将来検討):** LLMによる動的な要素（問題生成など）の導入を検討する。
* **フェーズ4 (演出強化):** 応援画像生成などのゲーム演出を追加する。

### 5.2. フェーズ1の主要タスク

1.  **環境構築:** Python開発環境、Docker (for Elasticsearch), Gradio, OpenAI SDK, `elasticsearch-py` 等のセットアップ。
2.  **サンプルデータ準備:** 固定JSONデータを選定/作成し、Elasticsearch投入スクリプトを用意。
3.  **クエスト定義:** フェーズ1対象クエスト（問題文、期待結果、評価基準、ヒント案等）を具体化し、SQLite等に格納する形式を決定・実装。
4.  **基本UI作成 (Gradio):** クエスト表示、クエリ入力エリア、実行ボタン、結果表示エリア、フィードバック表示エリア等の画面を作成。
5.  **バックエンド実装 (コア):** クエリ実行ロジック、基本正誤判定ロジック、クエスト進行管理ロジック。
6.  **LLM連携 (基本):** OpenAI Assistantの基本設定（システムプロンプト、ツール定義）、基本的なヒント生成機能の実装。
7.  **DB設計・実装 (基本):** SQLiteのテーブルスキーマ設計（ユーザー、クエスト、履歴など）と基本的なCRUD処理の実装。
